# Rust Memory & Collections Talk Series

20 focused talks around the borrow checker, Box, pointers, arrays, vectors, and maps.

---

## Talk 1: Mental Model of Ownership & Borrowing

**Goal:** Build an intuition for Rust’s ownership system before the compiler starts shouting.  

- Why ownership exists: safety without a GC  
- Three rules: one owner, many shared borrows, one unique borrow  
- Move vs copy vs clone with simple examples  
- Stack vs heap in the context of ownership  
- Common compiler errors and how to read them calmly  

---

## Talk 2: The Borrow Checker – Friend, Not Enemy

**Goal:** Demystify what the borrow checker is actually checking.  

- What the borrow checker tracks under the hood (lifetimes & aliasing)  
- Non-lexical lifetimes (NLL) – why `let x = ...;` sometimes fixes code  
- Aliasing + mutation: why `&T` and `&mut T` can’t coexist  
- Typical patterns that trigger errors (loops, branches, early returns)  
- Strategies to “work with” the borrow checker, not fight it  

---

## Talk 3: Lifetimes – Telling the Compiler Who Outlives Whom

**Goal:** Make lifetime annotations feel mechanical, not mystical.  

- What a lifetime actually represents (a region in code)  
- When the compiler can elide lifetimes and when it cannot  
- Functions, structs, and impls with explicit lifetimes  
- Tying lifetimes together: `&'a T`, `&'a mut T`, and structs with refs  
- Lifetime gotchas with returned references & local variables  

---

## Talk 4: Box Basics – Owning Data on the Heap

**Goal:** Understand when and why to use `Box<T>`.  

- Stack vs heap recap in Rust terms  
- Creating and using `Box<T>`; deref coercion in action  
- Moving boxes, passing them to functions, returning them  
- Recursive types and `Box` (linked lists, trees)  
- Performance considerations: when Box is overkill  

---

## Talk 5: Box, Drop, and Custom Smart Pointers

**Goal:** Dive deeper into heap allocation, dropping, and custom pointer types.  

- How `Box<T>` implements `Drop` and `Deref`  
- Writing a minimal custom smart pointer  
- RAII: using destructors for cleanup (files, network, locks)  
- Interaction of Box with traits like `Send` and `Sync`  
- Pitfalls: double-free in unsafe code and how Box prevents it  

---

## Talk 6: References & Raw Pointers – Safe vs Unsafe

**Goal:** Contrast Rust references (`&T`, `&mut T`) with raw pointers (`*const T`, `*mut T`).  

- Memory safety guarantees of references  
- When raw pointers are needed (FFI, self-referential structures, arenas)  
- Creating raw pointers from references and Boxes  
- `unsafe` blocks: what is *actually* unsafe here?  
- Dereferencing raw pointers and UB landmines  

---

## Talk 7: Building Intuition with Arrays

**Goal:** Understand fixed-size arrays as contiguous memory blocks.  

- Defining arrays: `[T; N]` and their size at compile time  
- Stack layout and cost of copying arrays  
- Indexing, bounds checking, and panics  
- Arrays vs tuples (homogeneous vs heterogeneous)  
- When arrays are preferable over Vecs  

---

## Talk 8: From Arrays to Slices – Borrowing Views of Data

**Goal:** Explain slices as borrowed windows into contiguous data.  

- `&[T]` and `&mut [T]` as “views” over arrays & Vecs  
- Slicing syntax: `&arr[..]`, `&arr[1..=3]`  
- Passing slices to functions for generic APIs  
- Iterating over slices, `chunks`, `windows` patterns  
- Relationship between `str` and `[u8]`  

---

## Talk 9: Vectors 101 – The Workhorse of Rust Collections

**Goal:** Introduce `Vec<T>` and its core behavior.  

- Creating vectors: `vec![]`, `Vec::new()`, `with_capacity`  
- Push, pop, insert, remove, and their complexity  
- Capacity vs length and how reallocation works  
- Iterating: `iter`, `iter_mut`, `into_iter`  
- When to prefer Vec over arrays or linked structures  

---

## Talk 10: Vectors Under the Hood – Layout, Capacity & Reallocation

**Goal:** Look at the internal model of `Vec<T>` and performance trade-offs.  

- How a Vec is represented (pointer, length, capacity)  
- Growth strategy and amortized O(1) pushes  
- Reserve, shrink_to_fit, and tuning allocations  
- Memory fragmentation and cache-friendliness  
- Pitfalls: holding references across reallocation  

---

## Talk 11: Maps in Rust – HashMap Basics

**Goal:** Introduce `HashMap<K, V>` for key-value storage.  

- When and why to use maps  
- Creating, inserting, reading: `insert`, `get`, `entry`  
- Hashing and equality: `Eq` and `Hash` traits  
- Ownership patterns with keys and values  
- Common mistakes: `unwrap`, missing keys, using references as keys  

---

## Talk 12: HashMap Under the Hood – Hashing & Buckets

**Goal:** Understand how HashMap works internally.  

- Buckets, load factor, and resizing  
- Collision resolution strategies at a high level  
- Influence of hash quality on performance  
- Custom hasher: when and why (`BuildHasher`)  
- Security notes: DOS via hash collisions and Rust’s default protections  

---

## Talk 13: BTreeMap, Ordering, and Range Queries

**Goal:** Explore `BTreeMap` and ordered maps.  

- Differences between `HashMap` and `BTreeMap`  
- When ordered maps are better (range queries, sorted iteration)  
- Big-O characteristics of lookup, insert, remove  
- Walking keys in order, using `range`  
- Memory usage and cache behavior comparisons  

---

## Talk 14: Ownership Patterns with Collections

**Goal:** Combine ownership & borrowing with Vec and maps.  

- Owning vs borrowing elements from Vec / HashMap  
- Iteration patterns: by value, by ref, by mut ref  
- Returning references to elements safely  
- Lifetimes and collection methods (`get`, `iter`, `filter`)  
- Common anti-patterns and how to refactor them away  

---

## Talk 15: Interior Mutability – When & Why to Use It

**Goal:** Show how to temporarily “bend” the borrow rules correctly.  

- Problem: needing mutation behind shared references  
- `Cell<T>`, `RefCell<T>` basics and use cases  
- Runtime borrow checking vs compile-time borrow checking  
- `Rc<RefCell<T>>` in single-threaded code  
- When interior mutability is a smell vs when it’s justified  

---

## Talk 16: Smart Pointers Gallery – Box, Rc, Arc & Friends

**Goal:** Place Box in context with other smart pointers.  

- Comparing `Box<T>`, `Rc<T>`, `Arc<T>` in terms of ownership  
- Use cases for `Rc` and reference counting cycles  
- `Weak<T>` and breaking cycles  
- Sharing collections: `Arc<Vec<T>>`, `Arc<HashMap<K, V>>`  
- Trade-offs: allocation cost, atomic vs non-atomic refcounting  

---

## Talk 17: Zero-Cost Abstractions for Arrays, Vecs & Maps

**Goal:** Show how Rust abstractions compile down efficiently.  

- Inlining and monomorphization for generics on collections  
- Bounds checking and when it’s optimized out  
- Iterators vs manual loops – performance comparison  
- `for` loops, iterators, and combinators (`map`, `filter`, etc.)  
- Using `cargo asm` / godbolt (conceptually) to inspect assembly  

---

## Talk 18: Safe APIs over Unsafe Pointers & Raw Memory

**Goal:** Design a small safe abstraction on top of unsafe operations.  

- Example: custom chunked buffer or arena using raw pointers  
- `NonNull<T>` and pointer arithmetic  
- Ensuring safety invariants: designing the API surface  
- Using arrays/Vecs internally while exposing a safe abstraction  
- Testing & documenting invariants for future maintainers  

---

## Talk 19: Real-World Case Study – Implementing a Tiny HashMap

**Goal:** Reinforce concepts by building a simple map type.  

- Start with `Vec<Option<(K, V)>>` or similar backing storage  
- Naive hashing & linear probing  
- Insert, get, remove operations  
- Dealing with tombstones / deleted entries  
- Comparing this toy implementation to `std::collections::HashMap`  

---

## Talk 20: Putting It All Together – A Mini In-Memory Database

**Goal:** Combine borrow checker, Box, pointers, arrays, Vecs, and maps.  

- Design: a simple key-value store with indexed tables  
- Data model: arrays for fixed-size fields, Vecs for records  
- Using HashMap/BTreeMap as indexes over records  
- Ownership story: who owns what, who borrows what  
- Evolving the design: performance tuning & refactoring with safety

---